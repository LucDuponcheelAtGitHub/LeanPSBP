-- instance
--     [Applicative computation]
--     [Monoid ε] :
--   Applicative (FailureT ε computation) where
--   pure :=
--     λ α =>
--       .mk (pure (Sum.inr α))
--   seq :=
--     λ ⟨cεoαfβ⟩ ufftεcα =>
--       let cεoα :=
--         (ufftεcα ()).toComputationOfSum
--       -- TODO avoid duplication
--       let εoαfεoαfβfεoβ {α β : Type} :
--         (ε ⊕ α) → (ε ⊕ (α → β)) → (ε ⊕ β) :=
--           λ εoα εoαfβ =>
--             match εoα with
--               | .inl ε =>
--                 match εoα with
--                   | .inl ε' => .inl (ε * ε')
--                   | .inr _  => .inl ε
--               | .inr α =>
--                 match εoαfβ with
--                   | .inl ε' => .inl ε'
--                   | .inr αfβ  => .inr (αfβ α)
--       ⟨εoαfεoαfβfεoβ <$> cεoα <*> cεoαfβ⟩

-- instance
--     [Applicative computation]
--     [Monoid ε] :
--   Applicative (FailureT ε computation) where
--   pure :=
--     λ α =>
--       .mk (pure (Sum.inr α))
--   seq :=
--     λ ⟨cεoαfβ⟩ ufftεcα =>
--       let cεoαfβ :=
--         cεoαfβ
--       let cεoα :=
--         (ufftεcα ()).toComputationOfSum
--       -- TODO avoid duplication
--       let εoαfεoαfβfεoβ {α β : Type} :
--         (ε ⊕ α) → (ε ⊕ (α → β)) → (ε ⊕ β) :=
--           λ εoα εoαfβ =>
--             match εoα with
--               | .inl ε =>
--                 match εoα with
--                   | .inl ε' => .inl (ε * ε')
--                   | .inr _  => .inl ε
--               | .inr α =>
--                 match εoαfβ with
--                   | .inl ε' => .inl ε'
--                   | .inr αfβ  => .inr (αfβ α)
--       ⟨εoαfεoαfβfεoβ <$> cεoα <*> cεoαfβ⟩

-- instance {ε : Type}
--     [Applicative (FailureT ε computation)]
--     [Monoid ε]:
--   Validation ε
--     (FromComputationValuedFunction
--       (FailureT ε computation)) where
--   noFailedValidations :=
--     ⟨λ _ => pure $ .inl $ ν⟩
--   addFailedValidationWith :=
--     let εoβfεoβfεoβ {β : Type} :
--       (ε ⊕ β) → (ε ⊕ β) → (ε ⊕ β) :=
--         λ εoα εoβ =>
--           match εoα with
--             | .inl ε => .inl ε
--             | .inr _ =>
--               match εoβ with
--                 | .inl ε' => .inl ε'
--                 | .inr β  => .inr β
--     λ αfε ⟨αpεoβ⟩ =>
--       ⟨λ α =>
--         εoβfεoβfεoβ <$>
--         (pure $ .inl $ αfε α) <*>
--         αpεoβ α⟩

-- def liftA2
--     [Applicative computation]:
--   (α → β → γ) →
--   computation α → computation β → computation γ :=
--     λ αpβpγ cα cβ => αpβpγ <$> cα <*> cβ

-- def curry : (α × β → γ) → (α → β → γ) :=
--   λ αaβpγ (α β) => αaβpγ (α, β)

-- def uncurry : (α → β → γ) → (α × β → γ) :=
--   λ αpβpγ (α, β) => αpβpγ α β

-- def liftA2'
--     [Applicative computation]:
--   (α × β → γ) →
--   computation α × computation β → computation γ :=
--     λ αaβpγ => uncurry (liftA2 (curry αaβpγ))

-- def swap [Applicative computation] :
--    computation α × computation β → computation (α × β) :=
--      λ (α, β) => (λ (α β) => (α, β)) <$> α <*> β
